<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="310fa85e-1733-4606-aa91-ea7e307abfcb" name="Changes" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectColorInfo"><![CDATA[{
  "associatedIndex": 0
}]]></component>
  <component name="ProjectId" id="2kW2GESjLqC3WM3l9LIjQlegXlz" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "JUnit.DateTimeTest.localDateTime.executor": "Run",
    "JUnit.DateTimeTest.nextFriday13Test.executor": "Debug",
    "JUnit.DateTimeTest.pastTemporalDateProximityTest.executor": "Run",
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "git-widget-placeholder": "master",
    "kotlin-language-version-configured": "true"
  }
}]]></component>
  <component name="RunManager" selected="JUnit.DateTimeTest.pastTemporalDateProximityTest">
    <configuration name="DateTimeTest.localDateTime" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
      <module name="JavaDateTime" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="telran.datetime.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <option name="PACKAGE_NAME" value="telran.datetime" />
      <option name="MAIN_CLASS_NAME" value="telran.datetime.DateTimeTest" />
      <option name="METHOD_NAME" value="localDateTime" />
      <option name="TEST_OBJECT" value="method" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="DateTimeTest.nextFriday13Test" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
      <module name="JavaDateTime" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="telran.datetime.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <option name="PACKAGE_NAME" value="telran.datetime" />
      <option name="MAIN_CLASS_NAME" value="telran.datetime.DateTimeTest" />
      <option name="METHOD_NAME" value="nextFriday13Test" />
      <option name="TEST_OBJECT" value="method" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="DateTimeTest.pastTemporalDateProximityTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
      <module name="JavaDateTime" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="telran.datetime.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <option name="PACKAGE_NAME" value="telran.datetime" />
      <option name="MAIN_CLASS_NAME" value="telran.datetime.DateTimeTest" />
      <option name="METHOD_NAME" value="pastTemporalDateProximityTest" />
      <option name="TEST_OBJECT" value="method" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="JUnit.DateTimeTest.pastTemporalDateProximityTest" />
        <item itemvalue="JUnit.DateTimeTest.nextFriday13Test" />
        <item itemvalue="JUnit.DateTimeTest.localDateTime" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="310fa85e-1733-4606-aa91-ea7e307abfcb" name="Changes" comment="" />
      <created>1723384917001</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1723384917001</updated>
    </task>
    <servers />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="9dc04f">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/test/java/telran/datetime/DateTimeTest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                </list>
              </option>
              <option name="id" value="9dc04f" />
              <option name="initiateTms" value="1723397348992" />
              <option name="request" value=" поясни, что это за класс - TemporalAdjuster adjuster" />
              <option name="response" value="" />
              <option name="responseDescription" value="`TemporalAdjuster` — это интерфейс в пакете `java.time.temporal`, который используется для выполнения операций с объектами времени, такими как `LocalDate`, `LocalDateTime`, `ZonedDateTime` и другими, изменяя их в соответствии с определенными правилами. &#10;&#10;Класс, реализующий интерфейс `TemporalAdjuster`, должен переопределить метод `adjustInto(Temporal temporal)`, который принимает объект `Temporal` и возвращает новый объект `Temporal` с примененными изменениями.&#10;&#10;В данном случае, класс `NextFriday13` реализует интерфейс `TemporalAdjuster` и предназначен для нахождения следующей даты, которая будет пятницей 13-го числа. &#10;&#10;### Пример использования&#10;&#10;В тестовом методе `nextFriday13Test` создается объект `NextFriday13` и используется для изменения даты:&#10;&#10;```java&#10;@Test&#10;void nextFriday13Test()&#10;{&#10;    LocalDate current = LocalDate.of(2024, 8, 11); // Текущая дата&#10;    LocalDate expected = LocalDate.of(2024, 9, 13); // Ожидаемая следующая пятница 13-е&#10;    TemporalAdjuster adjuster = new NextFriday13(); // Создание экземпляра NextFriday13&#10;&#10;    assertEquals(expected, current.with(adjuster)); // Проверка, что adjuster корректно находит следующую пятницу 13-е&#10;    assertThrows(RuntimeException.class, () -&gt; LocalTime.now().with(adjuster)); // Проверка, что adjuster выбрасывает исключение для неподдерживаемых типов Temporal&#10;}&#10;```&#10;&#10;### Как это работает&#10;&#10;1. **Создание текущей даты**: `LocalDate current = LocalDate.of(2024, 8, 11);`&#10;2. **Создание ожидаемой даты**: `LocalDate expected = LocalDate.of(2024, 9, 13);`&#10;3. **Создание экземпляра `NextFriday13`**: `TemporalAdjuster adjuster = new NextFriday13();`&#10;4. **Применение `adjuster` к текущей дате**: `current.with(adjuster)`, что должно вернуть следующую пятницу 13-е.&#10;5. **Проверка результата**: `assertEquals(expected, current.with(adjuster));`&#10;6. **Проверка исключения**: `assertThrows(RuntimeException.class, () -&gt; LocalTime.now().with(adjuster));`, чтобы убедиться, что `adjuster` выбрасывает исключение при попытке применить его к неподдерживаемому типу `Temporal`.&#10;&#10;Таким образом, `TemporalAdjuster` позволяет вам создавать настраиваемые правила для изменения объектов времени, и `NextFriday13` — это пример такого правила, которое находит следующую пятницу 13-е." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1723397357242" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                  <option value="$PROJECT_DIR$/src/test/java/telran/datetime/DateTimeTest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="a3ed4e">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                </list>
              </option>
              <option name="id" value="a3ed4e" />
              <option name="initiateTms" value="1723397528146" />
              <option name="request" value=" А это что такое? ChronoField" />
              <option name="response" value="" />
              <option name="responseDescription" value="`ChronoField` — это перечисление (`enum`) в пакете `java.time.temporal`, которое представляет стандартные поля даты и времени. Эти поля могут быть использованы для доступа к различным компонентам даты и времени, таким как год, месяц, день, час, минута и т.д.&#10;&#10;### Основные поля `ChronoField`&#10;&#10;Некоторые из наиболее часто используемых полей `ChronoField` включают:&#10;&#10;- `ChronoField.YEAR`: год&#10;- `ChronoField.MONTH_OF_YEAR`: месяц года (1-12)&#10;- `ChronoField.DAY_OF_MONTH`: день месяца (1-31)&#10;- `ChronoField.DAY_OF_WEEK`: день недели (1-7, где 1 — это понедельник)&#10;- `ChronoField.HOUR_OF_DAY`: час дня (0-23)&#10;- `ChronoField.MINUTE_OF_HOUR`: минута часа (0-59)&#10;- `ChronoField.SECOND_OF_MINUTE`: секунда минуты (0-59)&#10;&#10;### Пример использования&#10;&#10;В вашем классе `NextFriday13` `ChronoField` используется для доступа и изменения дня месяца и дня недели:&#10;&#10;```java&#10;public class NextFriday13 implements TemporalAdjuster {&#10;&#10;    @Override&#10;    public Temporal adjustInto(Temporal temporal) {&#10;        Temporal temp = set13Month(temporal);&#10;        while (temp.get(ChronoField.DAY_OF_WEEK) != DayOfWeek.FRIDAY.getValue()) {&#10;            temp = temp.plus(1, ChronoUnit.MONTHS);&#10;        }&#10;        return temp;&#10;    }&#10;&#10;    private Temporal set13Month(Temporal temporal) {&#10;        if (temporal.get(ChronoField.DAY_OF_MONTH) &gt;= 13) {&#10;            temporal = temporal.plus(1, ChronoUnit.MONTHS);&#10;        }&#10;        temporal = temporal.with(ChronoField.DAY_OF_MONTH, 13);&#10;        return temporal;&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение кода&#10;&#10;1. **Метод `adjustInto`**:&#10;    - `Temporal temp = set13Month(temporal);`: Устанавливает 13-е число месяца.&#10;    - `while (temp.get(ChronoField.DAY_OF_WEEK) != DayOfWeek.FRIDAY.getValue()) { temp = temp.plus(1, ChronoUnit.MONTHS); }`: Цикл, который добавляет месяцы, пока день недели не станет пятницей.&#10;    - `return temp;`: Возвращает результат.&#10;&#10;2. **Метод `set13Month`**:&#10;    - `if (temporal.get(ChronoField.DAY_OF_MONTH) &gt;= 13) { temporal = temporal.plus(1, ChronoUnit.MONTHS); }`: Если текущий день месяца &gt;= 13, добавляет один месяц.&#10;    - `temporal = temporal.with(ChronoField.DAY_OF_MONTH, 13);`: Устанавливает 13-е число месяца.&#10;    - `return temporal;`: Возвращает результат.&#10;&#10;### Заключение&#10;&#10;`ChronoField` предоставляет удобный способ доступа к различным компонентам даты и времени, что делает его полезным для манипуляций с объектами времени в Java. В вашем классе `NextFriday13` `ChronoField` используется для проверки и установки дня месяца и дня недели, что позволяет корректно находить следующую пятницу 13-е." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1723397535956" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="cac1b3">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/test/java/telran/datetime/DateTimeTest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/PastTemporalDateProximity.java" />
                </list>
              </option>
              <option name="id" value="cac1b3" />
              <option name="initiateTms" value="1723400990479" />
              <option name="request" value=" Скажи, как тут выводить содержимое массива, а не указатель?&#10;        for (Temporal tmp : temporals) {&#10;            ptdp.addTemporal(tmp);&#10;            System.out.printf(&quot;Added %s, result is %s \n&quot;, tmp, temporals);&#10;        }&#10;пока что вывод выглядит как:        &#10;Added 2024-04-16, result is [Ljava.time.temporal.Temporal;@76b10754 &#10;Added 1971-08-16, result is [Ljava.time.temporal.Temporal;@76b10754 &#10;Added 2022-11-30, result is [Ljava.time.temporal.Temporal;@76b10754" />
              <option name="response" value="" />
              <option name="responseDescription" value="Когда вы выводите массив напрямую, Java по умолчанию использует метод `toString()` объекта массива, который возвращает строку, представляющую указатель на массив, а не его содержимое. Чтобы вывести содержимое массива, вам нужно использовать методы, которые преобразуют массив в строку с его элементами.&#10;&#10;Для этого можно использовать класс `Arrays` из пакета `java.util`, который предоставляет метод `Arrays.toString()`, предназначенный для вывода содержимого массива.&#10;&#10;### Пример&#10;&#10;Вместо того чтобы выводить массив напрямую, используйте `Arrays.toString(temporals)`:&#10;&#10;```java&#10;for (Temporal tmp : temporals) {&#10;    ptdp.addTemporal(tmp);&#10;    System.out.printf(&quot;Added %s, result is %s \n&quot;, tmp, Arrays.toString(ptdp.getTemporal()));&#10;}&#10;```&#10;&#10;### Объяснение&#10;&#10;1. **Импорт класса `Arrays`**:&#10;   - Убедитесь, что у вас есть импорт для класса `Arrays`: `import java.util.Arrays;`.&#10;&#10;2. **Использование `Arrays.toString()`**:&#10;   - Метод `Arrays.toString()` принимает массив и возвращает строку, представляющую его содержимое.&#10;   - В данном случае, `Arrays.toString(ptdp.getTemporal())` вернет строку, содержащую все элементы массива `temporal` в виде списка.&#10;&#10;Таким образом, ваш вывод будет выглядеть как:&#10;&#10;```&#10;Added 2024-04-16, result is [2024-04-16]&#10;Added 1971-08-16, result is [2024-04-16, 1971-08-16]&#10;Added 2022-11-30, result is [2024-04-16, 1971-08-16, 2022-11-30]&#10;```&#10;&#10;Это позволит вам видеть содержимое массива, а не его указатель." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1723400995211" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/NextFriday13.java" />
                  <option value="$PROJECT_DIR$/src/test/java/telran/datetime/DateTimeTest.java" />
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/PastTemporalDateProximity.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="ec42bc">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/PastTemporalDateProximity.java" />
                </list>
              </option>
              <option name="id" value="ec42bc" />
              <option name="initiateTms" value="1723398991977" />
              <option name="request" value=" Расскажи мне (только не пиши код, просто объясни словами, ЧТО надо, но НЕ КАК это делать) для такого задания:&#10;public class PastTemporalDateProximity implements TemporalAdjuster&#10;{&#10;    //TODO some encapsulation&#10;    //array of temporals supprting Day, Month, Year (Dates)&#10;    @Override&#10;    public Temporal adjustInto(Temporal temporal) {&#10;        // TODO Auto-generated method stub&#10;        //return the temporal for the encapsulated array that is a nearest in past&#10;        return null;&#10;    }&#10;}" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, вот что нужно сделать для реализации класса `PastTemporalDateProximity`, который реализует интерфейс `TemporalAdjuster`:&#10;&#10;1. **Инкапсуляция массива дат**:&#10;   - Создайте приватное поле для хранения массива объектов `Temporal`, которые поддерживают день, месяц и год.&#10;   - Обеспечьте методы для добавления и удаления дат из этого массива, а также для получения текущего списка дат.&#10;&#10;2. **Реализация метода `adjustInto`**:&#10;   - Метод `adjustInto` должен принимать объект `Temporal` и возвращать ближайшую дату из массива, которая находится в прошлом относительно переданной даты.&#10;   - Пройдите по массиву дат и найдите ту, которая является ближайшей в прошлом по отношению к переданной дате.&#10;   - Если такой даты нет, верните переданную дату без изменений или выбросьте соответствующее исключение.&#10;&#10;3. **Обработка исключений**:&#10;   - Убедитесь, что метод корректно обрабатывает случаи, когда массив дат пуст или когда все даты в массиве находятся в будущем относительно переданной даты.&#10;&#10;4. **Тестирование**:&#10;   - Напишите тесты для проверки корректности работы метода `adjustInto`, включая граничные случаи, такие как пустой массив дат и все даты в будущем.&#10;&#10;Таким образом, вы создадите класс, который будет корректно находить ближайшую дату в прошлом из заданного массива дат относительно переданной даты." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1723398998029" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/telran/datetime/PastTemporalDateProximity.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>